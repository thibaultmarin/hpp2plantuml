#+TITLE: hpp2plantuml - Convert C++ header files to PlantUML
#+DATE: <2016-11-30 Wed>
#+TODO: TODO REVIEW | DONE DEFERRED ABANDONED
#+MACRO: tt \nbsp{}
#+PROPERTY: header-args+ :exports code :results silent
#+PROPERTY: header-args:python+ :tangle src/hpp2plantuml/hpp2plantuml.py :mkdirp yes

* REVIEW Motivation
  :PROPERTIES:
  :CUSTOM_ID: sec-intro
  :END:

#+NAME: doc-intro
#+BEGIN_SRC org
The purpose of this tool is to convert C++ header files to a UML representation
in [[https://plantuml.com][PlantUML]] syntax that can be used to generate with PlantUML.

[[https://plantuml.com][PlantUML]] is a program rendering UML diagrams from plain text inputs using an
expressive language.

This module generates the text input to PlantUML from C++ header files.  Its
ambition is limited but it should produce reasonable conversion for simple class
hierarchies.  It aims at supporting:
- class members with properties (~private~, ~method~, ~protected~), methods with
  basic qualifiers (~static~, abstract),
- inheritance relationships,
- composition relationships (very basic support).
#+END_SRC


* REVIEW License

The license adopted for this project is the MIT license.

#+NAME: license
#+BEGIN_SRC conf :tangle LICENSE

The MIT License (MIT)

Copyright (c) 2016 T

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

#+END_SRC


* REVIEW Requirements

This module has mostly standard dependencies; the only exception is the
[[http://senexcanis.com/open-source/cppheaderparser/][CppHeaderParser]] module used to parse header files.

#+NAME: py-dependency-list
| argparse        |
| CppHeaderParser |

The full list non-standard of dependencies is produced by the following source
block (adding either imports or dependency list used in [[#sec-package-setup-py][=setup.py=]]):

#+NAME: py-dependencies
#+BEGIN_SRC emacs-lisp :var output="import" :var dep-list=py-dependency-list :results value
(cond
 ((string= output "import")
  (mapconcat
   (lambda (el) (concat "import " (car el))) dep-list "\n"))
 ((string= output "requirements")
  (concat "["
          (mapconcat
           (lambda (el) (concat "'" (car el) "'")) dep-list ", ")
          "]")))
#+END_SRC

#+NAME: py-imports
#+BEGIN_SRC python :noweb yes
# %% Imports

import re
import operator
import glob
<<py-dependencies("import")>>
#+END_SRC

The tests rely on the [[http://nose.readthedocs.io/en/latest/][nosetest]] framework and the package documentation is built
with [[http://sphinx-doc.org][Sphinx]].


* REVIEW Module source code

The current version of the code is:
#+NAME: hpp2plantuml-version
: 0.0.dev0

#+NAME: get-version
#+BEGIN_SRC emacs-lisp :var ver=hpp2plantuml-version :var lang="python"
(cond ((string= lang "python")
       (format "'%s'" ver)))
#+END_SRC


#+NAME: doc-module
#+BEGIN_SRC org
The package relies on a layer of objects used as intermediate between the parsed
header files (parsed using ~CppHeaderParser~) and the text output for use with
PlantUML.

The main entry point ([[#sec-module-create-uml][~CreatePlantUMLFile~]]) takes as input a list of header
files and creates a [[#sec-module-diagram][~Diagram~]] object from it, which contains the internal object
representation extracted jointly from the input files.

Objects for different types (e.g. class, struct, etc.) are initialized at
instantiation time from the parsed header via the ~parse_members~ method.
Conversion to text input in PlantUML syntax is performed by the ~render~ method.

Relationships between objects are extracted from a ~Diagram~ object by listing
inheritance properties and parsing member types into [[#sec-module-relationship][relationship objects]].
#+END_SRC


** REVIEW String representation constants
   :PROPERTIES:
   :CUSTOM_ID: sec-module-constants
   :END:

Some constant variables are defined to store the PlantUML string representation
of elementary properties and links.
- The ~MEMBER_PROP_MAP~ variable maps class member types to corresponding
  PlantUML characters.
- The ~LINK_TYPE_MAP~ variable stores the PlantUML representation of inheritance
  and composition relationships.
- ~CONTAINER_TYPE_MAP~ associates object types with internal classes used for
  their representation.

#+NAME: py-constants
#+BEGIN_SRC python
# %% Constants


# Association between member property and PlantUML symbol
MEMBER_PROP_MAP = {
    'private': '-',
    'public': '+',
    'protected': '#'
}

# Links
LINK_TYPE_MAP = {
    'inherit': '<|--',
    'aggregation': 'o--',
    'composition': '*--'
}

# Assiocation between object names and objects
# - The first element is the object type name in the CppHeader object
# - The second element is the iterator used to loop over objects
# - The third element is a function returning the corresponding internal object
CONTAINER_TYPE_MAP = [
    ['classes', lambda objs: objs.items(), lambda obj: Class(obj)],
    ['structs', lambda objs: objs.items(), lambda obj: Struct(obj)],
    ['enums', lambda objs: objs, lambda obj: Enum(obj)]
]
#+END_SRC


** REVIEW Objects

C++ objects parsed by the =CppHeaderParser= module are converted to internal
objects which perform two tasks:
1. extract properties supported by PlantUML,
2. generate text following the PlantUML syntax representing the object

The module currently supports ~class~ and ~enum~ objects.  They are implemented
via the internal ~Class~ and ~Enum~ objects, which inherits from a common base
class.


*** REVIEW Base class
    :PROPERTIES:
    :CUSTOM_ID: sec-module-container
    :END:

C++ objects are represented by objects derived from the base ~Container~ class.
The ~Container~ class is abstract and contains:
- the container type (~class~, ~enum~, ~struct~),
- the object name,
- a list of members (e.g. class variable or method for a class object),
- a ~parse_members~ method which can build the list of members from a parsed
  header,
- a ~render~ method with renders the object to text, including the object
  definition (e.g. "class TestClass") and its members (e.g. member variables and
  methods).

#+NAME: py-obj-container
#+BEGIN_SRC python
# %% Base classes


class Container(object):
    """Base class for C++ objects

    This class defines the basic interface for parsed objects (e.g. class).
    """
    def __init__(self, container_type, name):
        """Class constructor

        Parameters
        ----------
        container_type : str
            String representation of container type (``class``, ``struct`` or
            ``enum``)
        name : str
            Object name
        """
        self._container_type = container_type
        self._name = name
        self._member_list = []

    def get_name(self):
        """Name property accessor

        Returns
        -------
        str
            Object name
        """
        return self._name

    def parse_members(self, header_container):
        """Initialize object from header (abstract method)

        Extract object from CppHeaderParser dictionary representing a class, a
        struct or an enum object.

        Parameters
        ----------
        header_container : CppClass, CppStruct or CppEnum
            Parsed header for container
        """
        raise NotImplementedError(
            'Derived class must implement :func:`parse_members`.')

    def render(self):
        """Render object to string

        Returns
        -------
        str
            String representation of object following the PlantUML syntax
        """
        container_str = self._render_container_def() + ' {\n'
        for member in self._member_list:
            container_str += '\t' + member.render() + '\n'
        container_str += '}\n'
        return container_str

    def comparison_keys(self):
        """Order comparison key between `ClassRelationship` objects

        Use the parent name, the child name then the link type as successive
        keys.

        Returns
        -------
        list
            `operator.attrgetter` objects for successive fields used as keys
        """
        return self._container_type, self._name

    def sort_members(self):
        """Sort container members

        sort the list of members by type and name
        """
        self._member_list.sort(key=lambda obj: obj.comparison_keys())

    def _render_container_def(self):
        """String representation of object definition

        Return the definition line of an object (e.g. "class MyClass").

        Returns
        -------
        str
            Container type and name as string
        """
        return self._container_type + ' ' + self._name
#+END_SRC

Members of ~Container~ objects (e.g. class member variable) are inherited from
the ~ContainerMember~ class.  The interface only includes a ~render~ method
returning a string representation of the member.  The base class
~ContainerMember~ defines this method abstract.

#+NAME: py-obj-container-member
#+BEGIN_SRC python
# %% Object member


class ContainerMember(object):
    """Base class for members of `Container` object

    This class defines the basic interface for object members (e.g. class
    variables, etc.)
    """
    def __init__(self, header_member, **kwargs):
        """Constructor

        Parameters
        ----------
        header_member : str
            Member name
        """
        self._name = header_member
        self._type = None

    def render(self):
        """Render object to string (abstract method)

        Returns
        -------
        str
            String representation of object member following the PlantUML
            syntax
        """
        raise NotImplementedError('Derived class must implement `render`.')

    def comparison_keys(self):
        """Order comparison key between `ClassRelationship` objects

        Use the parent name, the child name then the link type as successive
        keys.

        Returns
        -------
        list
            `operator.attrgetter` objects for successive fields used as keys
        """
        if self._type is not None:
            return self._type, self._name
        else:
            return self._name
#+END_SRC


*** REVIEW Classes

C++ class objects are represented using the ~Class~ class.  It extends the
[[#sec-module-container][~Container~]] class adding class properties (template, abstract) and a list of
parent classes.  It also offers a method to extract the types of its members,
which is used to determine composition relationships between classes.

#+NAME: py-render-classes
#+BEGIN_SRC python
# %% Class object


class Class(Container):
    """Representation of C++ class

    This class derived from `Container` specializes the base class to handle
    class definition in C++ headers.

    It supports:

    ,* abstract and template classes
    ,* member variables and methods (abstract and static)
    ,* public, private, protected members (static)
    """
    def __init__(self, header_class):
        """Constructor

        Extract the class name and properties (template, abstract) and
        inheritance.  Then, extract the class members from the header using the
        :func:`parse_members` method.

        Parameters
        ----------
        header_class : list (str, CppClass)
            Parsed header for class object (two-element list where the first
            element is the class name and the second element is a CppClass
            object)
        """
        super().__init__('class', header_class[0])
        self._abstract = header_class[1]['abstract']
        self._template_type = None
        if 'template' in header_class[1]:
            self._template_type = header_class[1]['template']
        self._inheritance_list = [re.sub('<.*>', '', parent['class'])
                                  for parent in header_class[1]['inherits']]
        self.parse_members(header_class[1])

    def parse_members(self, header_class):
        """Initialize class object from header

        This method extracts class member variables and methods from header.

        Parameters
        ----------
        header_class : CppClass
            Parsed header for class
        """
        member_type_map = [
            ['properties', ClassVariable],
            ['methods', ClassMethod]
        ]
        for member_type, member_type_handler in member_type_map:
            for member_prop in MEMBER_PROP_MAP.keys():
                member_list = header_class[member_type][member_prop]
                for header_member in member_list:
                    self._member_list.append(
                        member_type_handler(header_member, member_prop))

    def build_variable_type_list(self):
        """Get type of member variables

        This function extracts the type of each member variable.  This is used
        to list composition relationships between classes.

        Returns
        -------
        list(str)
            List of types (as string) for each member variable
        """
        variable_type_list = []
        for member in self._member_list:
            if isinstance(member, ClassVariable):
                variable_type_list.append(member.get_type())
        return variable_type_list

    def build_inheritance_list(self):
        """Get inheritance list

        Returns
        -------
        list(str)
            List of class names the current class inherits from
        """
        return self._inheritance_list

    def _render_container_def(self):
        """Create the string representation of the class

        Return the class name with template and abstract properties if
        present.  The output string follows the PlantUML syntax.

        Returns
        -------
        str
            String representation of class
        """
        class_str = self._container_type + ' ' + self._name
        if self._abstract:
            class_str = 'abstract ' + class_str
        if self._template_type is not None:
            class_str += ' <{0}>'.format(self._template_type)
        return class_str
#+END_SRC


*** REVIEW Class members
    :PROPERTIES:
    :CUSTOM_ID: sec-module-class-member
    :END:

Members of C++ classes are represented by the ~ClassMember~ object, which
inherits from the base [[#sec-module-container][~ContainerMember~]] class.  The ~ClassMember~ class is a
super-class for [[#sec_class_properties][member variables]] and [[#sec_class_methods][class methods]].

In addition to the base representation, ~ClassMember~ objects store the type of
the object, the scope (e.g. public or private) and a static flag.  The rendering
of the member is mostly common between variables and methods.  The ~ClassMember~
class provides the common rendering and relies on child classes implementing the
~_render_name~ method for specialization.

#+NAME: py-obj-class_member
#+BEGIN_SRC python
# %% Class member


class ClassMember(ContainerMember):
    """Class member (variable and method) representation

    This class is the base class for class members.  The representation
    includes the member type (variable or method), name, scope (``public``,
    ``private`` or ``protected``) and a static flag.

    """
    def __init__(self, class_member, member_scope='private'):
        """Constructor

        Parameters
        ----------
        class_member : CppVariable or CppMethod
            Parsed member object (variable or method)
        member_scope : str
            Member scope property: ``public``, ``private`` or ``protected``
        """
        super().__init__(class_member['name'])
        self._type = None
        self._static = class_member['static']
        self._scope = member_scope

    def render(self):
        """Get string representation of member

        The string representation is with the scope indicator and a static
        keyword when the member is static.  It is postfixed by the type (return
        type for class methods).  The inner part of the returned string
        contains the variable name and signature for methods.  This is obtained
        using the :func:`_render_name` method.

        Returns
        -------
        str
            String representation of member
        """
        member_str = MEMBER_PROP_MAP[self._scope] + \
                      ('{static} ' if self._static else '') + \
                      self._render_name() + \
                      (' : ' + self._type if self._type else '')
        return member_str

    def _render_name(self):
        """Get member name

        By default (for member variables), this returns the member name.
        Derived classes can override this to control the name rendering
        (e.g. add the function prototype for member functions)
        """
        return self._name
#+END_SRC


**** REVIEW Properties
    :PROPERTIES:
    :CUSTOM_ID: sec_class_properties
    :END:

The specialization required for class member variables is minimal: the member
type is extracted from the parsed dictionary, and the rest of the setup is left
to the [[#sec-module-class-member][parent class]].

#+NAME: py-obj-class_variable
#+BEGIN_SRC python
# %% Class variable


class ClassVariable(ClassMember):
    """Object representation of class member variables

    This class specializes the `ClassMember` object for member variables.
    Additionally to the base class, it stores variable types as strings.  This
    is used to establish composition relationships between objects.
    """
    def __init__(self, class_variable, member_scope='private'):
        """Constructor

        Parameters
        ----------
        class_variable : CppVariable
            Parsed class variable object
        member_scope : str
            Scope property to member variable
        """
        assert(isinstance(class_variable,
                          CppHeaderParser.CppHeaderParser.CppVariable))

        super().__init__(class_variable, member_scope)

        self._type = _cleanup_type(class_variable['type'])

    def get_type(self):
        """Variable type accessor

        Returns
        -------
        str
            Variable type as string
        """
        return self._type
#+END_SRC


**** REVIEW Methods
    :PROPERTIES:
    :CUSTOM_ID: sec_class_methods
    :END:

Member methods store additional information on the class members: an abstract
flag is used to purely virtual methods, the method name is modified to prefix a
tilde sign (=~=) for destructor methods and a list of parameters is stored.

The name rendering includes the method signature.  An option to shorten the list
of parameters by keeping only types or names or using ellipsis may be
implemented in the future.

#+NAME: py-obj-class_method
#+BEGIN_SRC python
# %% Class method


class ClassMethod(ClassMember):
    """Class member method representation

    This class extends `ClassMember` for member methods.  It stores additional
    method properties (abstract, destructor flag, input parameter types).
    """
    def __init__(self, class_method, member_scope):
        """Constructor

        The method name and additional properties are extracted from the parsed
        header.  A list of parameter types is also stored to retain the
        function signature.  The ``~`` character is also appended to destructor
        methods.

        Parameters
        ----------
        class_method : CppMethod
            Parsed class member method
        member_scope : str
            Scope of the member method
        """
        assert(isinstance(class_method,
                          CppHeaderParser.CppHeaderParser.CppMethod))

        super().__init__(class_method, member_scope)

        self._type = _cleanup_type(class_method['returns'])
        if class_method['returns_pointer']:
            self._type += '*'
        elif class_method['returns_reference']:
            self._type += '&'
        self._abstract = class_method['pure_virtual']
        if class_method['destructor']:
            self._name = '~' + self._name
        self._param_list = []
        for param in class_method['parameters']:
            self._param_list.append([_cleanup_type(param['type']),
                                     param['name']])

    def _render_name(self):
        """Internal rendering of method name

        This method extends the base :func:`ClassMember._render_name` method by
        adding the method signature to the returned string.

        Returns
        -------
        str
            The method name (prefixed with the ``abstract`` keyword when
            appropriate) and signature
        """
        assert(not self._static or not self._abstract)

        method_str = ('{abstract} ' if self._abstract else '') + \
                     self._name + '(' + \
                     ', '.join(' '.join(it) for it in self._param_list) + ')'

        return method_str
#+END_SRC


*** REVIEW Structures

While ~struct~ objects are currently not supported, their addition should be
relatively straightforward and the ~Struct~ class may simply inherit from the
~Class~ class.  The following should give a starting point.

#+NAME: py-render-structs
#+BEGIN_SRC python
# %% Struct object


class Struct(Class):
    """Representation of C++ struct objects

    This class derived is almost identical to `Class`, the only difference
    being the container type name ("struct" instead of "class").
    """
    def __init__(self, header_struct):
        """Class constructor

        Parameters
        ----------
        header_struct : list (str, CppStruct)
            Parsed header for struct object (two-element list where the first
            element is the structure name and the second element is a CppStruct
            object)
        """
        super().__init__(header_struct[0])
        super(Class).__init__('struct')
#+END_SRC


*** REVIEW Enumeration lists

The ~Enum~ class representing enumeration object is a trivial extension of the
base [[#sec-module-container][~Container~]] class.  Note that the enumeration elements are rendered without
the actual values.

#+NAME: py-render-enums
#+BEGIN_SRC python
# %% Enum object


class Enum(Container):
    """Class represnting enum objects

    This class defines a simple object inherited from the base `Container`
    class.  It simply lists enumerated values.
    """
    def __init__(self, header_enum):
        """Constructor

        Parameters
        ----------
        header_enum : CppEnum
            Parsed CppEnum object
        """
        super().__init__('enum', header_enum['name'])
        self.parse_members(header_enum)

    def parse_members(self, header_enum):
        """Extract enum values from header

        Parameters
        ----------
        header_enum : CppEnum
            Parsed `CppEnum` object
        """
        for value in header_enum['values']:
            self._member_list.append(EnumValue(value['name']))


class EnumValue(ContainerMember):
    """Class representing values in enum object

    This class only contains the name of the enum value (the actual integer
    value is ignored).
    """
    def __init__(self, header_value, **kwargs):
        """Constructor

        Parameters
        ----------
        header_value : str
            Name of enum member
        """
        super().__init__(header_value)

    def render(self):
        """Rendering to string

        This method simply returns the variable name

        Returns
        -------
        str
            The enumeration element name
        """
        return self._name
#+END_SRC


*** REVIEW Class relationships
    :PROPERTIES:
    :CUSTOM_ID: sec-module-relationship
    :END:

The current version only supports inheritance and composition relationships.  No
attempt is made to differentiate between composition and aggregation
relationships from the code; instead, an object have as a member of a type
defined by another class is assumed to be a composition relationship.

The base ~ClassRelationship~ class defines the common properties of class
relationships: a parent, a child and a connection type.  All are saved as
strings and the text representation of a connection link is obtained from the
[[#sec-module-constants][~CONTAINER_TYPE_MAP~ constant]].

#+NAME: py-class_relationship
#+BEGIN_SRC python
# %% Class connections


class ClassRelationship(object):
    """Base object for class relationships

    This class defines the common structure of class relationship objects.
    This includes a parent/child pair and a relationship type (e.g. inheritance
    or composition).
    """
    def __init__(self, link_type, c_parent, c_child):
        """Constructor

        Parameters
        ----------
        link_type : str
            Relationship type: ``inherit`` or ``composition``
        c_parent : str
            Name of parent class
        c_child : str
            Name of child class
        """
        self._parent = c_parent
        self._child = c_child
        self._link_type = link_type

    def comparison_keys(self):
        """Order comparison key between `ClassRelationship` objects

        Compare alphabetically based on the parent name, the child name then
        the link type.

        Returns
        -------
        list
            `operator.attrgetter` objects for successive fields used as keys
        """
        return self._parent, self._child, self._link_type

    def render(self):
        """Render class relationship to string

        This method generically appends the parent name, a rendering of the
        link type (obtained from the :func:`_render_link_type` method) and the
        child object name.

        Returns
        -------
        str
            The string representation of the class relationship following the
            PlantUML syntax
        """
        return self._parent + ' ' + self._render_link_type() + \
            ' ' + self._child

    def _render_link_type(self):
        """Internal representation of link

        The string representation is obtained from the `LINK_TYPE_MAP`
        constant.

        Returns
        -------
        str
            The link between parent and child following the PlantUML syntax
        """
        return LINK_TYPE_MAP[self._link_type]
#+END_SRC


**** REVIEW Inheritance

The inheritance relationship is a straightforward specialization of the base
~ClassRelationship~ class: it simply forces the link type to be "inherit".

#+NAME: py-class_inheritance
#+BEGIN_SRC python
# %% Class inheritance


class ClassInheritanceRelationship(ClassRelationship):
    """Representation of inheritance relationships

    This module extends the base `ClassRelationship` class by setting the link
    type to ``inherit``.
    """
    def __init__(self, c_parent, c_child):
        """Constructor

        Parameters
        ----------
        c_parent : str
            Parent class
        c_child : str
            Derived class
        """
        super().__init__('inherit', c_parent, c_child)
#+END_SRC


**** REVIEW Composition

The composition relationship specializes the base ~ClassRelationship~ class by
using the "composition" link type and adding a ~count~ field used to add a label
with the number of instances of the parent class in the PlantUML diagram (the
count is omitted when equal to one).

#+NAME: py-class_composition
#+BEGIN_SRC python
# %% Class composition


class ClassCompositionRelationship(ClassRelationship):
    """Representation of composition relationships

    This module extends the base `ClassRelationship` class by setting the link
    type to ``composition``.  It also keeps a count of composition, which is
    displayed near the arrow when using PlantUML.

    Composition relationships are simplified to represent the presence of a
    variable type (possibly within a container such as a list) in a class
    definition.
    """
    def __init__(self, c_parent, c_child, c_count=1):
        """Constructor

        Parameters
        ----------
        c_parent : str
            Class corresponding to the type of the member variable in the
            composition relationship
        c_child : str
            Child (or client) class of the composition relationship
        c_cout : int
            The number of members of ``c_child`` that are of type (possibly
            through containers) ``c_parent``
        """
        super().__init__('composition', c_parent, c_child)
        self._count = c_count

    def _render_link_type(self):
        """Internal link rendering

        This method overrides the default link rendering defined in
        :func:`ClassRelationship._render_link_type` to include a count near the
        end of the arrow.
        """
        count_str = '' if self._count == 1 else ' "%d"' % self._count
        return count_str + ' ' + LINK_TYPE_MAP[self._link_type]
#+END_SRC


*** REVIEW Diagram object
    :PROPERTIES:
    :CUSTOM_ID: sec-module-diagram
    :END:

The ~Diagram~ object is the main interface between the C++ code and the PlantUML
program.  It contains a list of objects parsed from the header files, maintains
lists of relationships and provides rendering facilities to produce a string
ready to process by PlantUML.

An example use case for the ~Diagram~ class could be:
#+NAME: py-diag-example
#+BEGIN_SRC python :tangle no
# Create object
diag = Diagram()
# Initialize from filename
diag.create_from_file(filename)
# Get output string following PlantUML syntax
output_string = diag.render()
#+END_SRC

The interface methods and their behavior are summarized in
Table{{{tt}}}[[tbl-diagram-interface]].

#+NAME: tbl-diagram-interface
| Method name             | input type | input list? | reset? | sort? | build lists? |
|-------------------------+------------+-------------+--------+-------+--------------|
| create_from_file        | file       | no          | yes    | yes   | yes          |
| create_from_file_list   | file       | yes         | yes    | yes   | yes          |
| add_from_file           | file       | no          | no     | no    | no           |
| add_from_file_list      | file       | yes         | no     | no    | no           |
| create_from_string      | string     | no          | yes    | yes   | yes          |
| create_from_string_list | string     | yes         | yes    | yes   | yes          |
| add_from_string         | string     | no          | no     | no    | no           |
| add_from_string_list    | string     | yes         | no     | no    | no           |

Functionally, the parsing is left to the =CppHeaderParser= module, the output of
which is parsed into internal objects using ~Container~ parsers.  The main
functionality of the ~Diagram~ class consists in building the relationship lists
between classes.  The assumption is that for a link to be stored, it must be
between two objects present in the ~Diagram~ object (no external
relationships).

To build the inheritance list, the objects are browsed and
~ClassInheritanceRelationship~ instances are added to the list whenever the
parent class is defined within the ~Diagram~ object.

Construction of the list of composition links is slightly more complex.  A first
run through the object extracts all the member types for ~Class~ objects.  Next
a list of (type, count) pairs is constructed for members of types defined within
the ~Diagram~ object.  Finally, the list is used to instantiate
~ClassCompositionRelationship~ objects stored in a list.

The rendering function builds a string containing the PlantUML preamble
postamble text for diagrams (~@startuml~, ~@enduml~), the rendered text for each
object and the rendered relationship links.

In order to ensure that the rendering is reproducible, a sorted mechanism has
been implemented for objects, members and relationships.  Objects and object
members are sorted by type and name and relationships are sorted by parent name,
child name and link type if necessary.  The ~add_from_*~ interface methods can
be used to avoid this feature.

#+NAME: py-obj-diagram
#+BEGIN_SRC python
# %% Diagram class


class Diagram(object):
    """UML diagram object

    This class lists the objects in the set of files considere, and the
    relationships between object.

    The main interface to the `Diagram` object is via the ``create_*`` and
    ``add_*`` methods.  The former parses objects and builds relationship lists
    between the different parsed objects.  The latter only parses objects and
    does not builds relationship lists.

    Each method has versions for file and string inputs and folder string lists
    and file lists inputs.
    """
    def __init__(self):
        """Constructor

        The `Diagram` class constructor simply initializes object lists.  It
        does not create objects or relationships.
        """
        self._objects = []
        self._inheritance_list = []
        self._composition_list = []

    def clear(self):
        """Reinitiliaze object"""
        self.__init__()

    def _sort_list(input_list):
        """Sort list using `ClassRelationship` comparison

        Parameters
        ----------
        input_list : list(ClassRelationship)
            Sort list using the :func:`ClassRelationship.comparison_keys`
            comparison function
        """
        input_list.sort(key=lambda obj: obj.comparison_keys())

    def sort_elements(self):
        """Sort elements in diagram

        Sort the objects and relationship links.  Objects are sorted using the
        :func:`Container.comparison_keys` comparison function and list are
        sorted using the `_sort_list` helper function.
        """
        self._objects.sort(key=lambda obj: obj.comparison_keys())
        for obj in self._objects:
            obj.sort_members()
        Diagram._sort_list(self._inheritance_list)
        Diagram._sort_list(self._composition_list)

    def _build_helper(self, input, build_from='string', flag_build_lists=True,
                      flag_reset=False):
        """Helper function to initialize a `Diagram` object from parsed headers

        Parameters
        ----------
        input : CppHeader or str or list(CppHeader) or list(str)
            Input of arbitrary type.  The processing depends on the
            ``build_from`` parameter
        build_from : str
            Determines the type of the ``input`` variable:

            ,* ``string``: ``input`` is a string containing C++ header code
            ,* ``file``: ``input`` is a filename to parse
            ,* ``string_list``: ``input`` is a list of strings containing C++
              header code
            ,* ``file_list``: ``input`` is a list of filenames to parse

        flag_build_lists : bool
            When True, relationships lists are built and the objects in the
            diagram are sorted, otherwise, only object parsing is performed
        flag_reset : bool
            If True, the object is initialized (objects and relationship lists
            are cleared) prior to parsing objects, otherwise, new objects are
            appended to the list of existing ones
        """
        if flag_reset:
            self.clear()
        if build_from in ('string', 'file'):
            self.parse_objects(input, build_from)
        elif build_from in ('string_list', 'file_list'):
            build_from_single = re.sub('_list$', '', build_from)
            for single_input in input:
                self.parse_objects(single_input, build_from_single)
        if flag_build_lists:
            self.build_relationship_lists()
            self.sort_elements()

    def create_from_file(self, header_file):
        """Initialize `Diagram` object from header file

        Wrapper around the :func:`_build_helper` function, with ``file`` input,
        building the relationship lists and with object reset.
        """
        self._build_helper(header_file, build_from='file',
                           flag_build_lists=True, flag_reset=True)

    def create_from_file_list(self, file_list):
        """Initialize `Diagram` object from list of header files

        Wrapper around the :func:`_build_helper` function, with ``file_list``
        input, building the relationship lists and with object reset.
        """
        self._build_helper(file_list, build_from='file_list',
                           flag_build_lists=True, flag_reset=True)

    def add_from_file(self, header_file):
        """Augment `Diagram` object from header file

        Wrapper around the :func:`_build_helper` function, with ``file`` input,
        skipping building of the relationship lists and without object reset
        (new objects are added to the object).
        """
        self._build_helper(header_file, build_from='file',
                           flag_build_lists=False, flag_reset=False)

    def add_from_file_list(self, file_list):
        """Augment `Diagram` object from list of header files

        Wrapper around the :func:`_build_helper` function, with ``file_list``
        input, skipping building of the relationship lists and without object
        reset (new objects are added to the object).
        """
        self._build_helper(file_list, build_from='file_list',
                           flag_build_lists=False, flag_reset=False)

    def create_from_string(self, header_string):
        """Initialize `Diagram` object from header string

        Wrapper around the :func:`_build_helper` function, with ``string``
        input, building the relationship lists and with object reset.
        """
        self._build_helper(header_string, build_from='string',
                           flag_build_lists=True, flag_reset=True)

    def create_from_string_list(self, string_list):
        """Initialize `Diagram` object from list of header strings

        Wrapper around the :func:`_build_helper` function, with ``string_list``
        input, skipping building of the relationship lists and with object
        reset.
        """
        self._build_helper(string_list, build_from='string_list',
                           flag_build_lists=True, flag_reset=True)

    def add_from_string(self, header_string):
        """Augment `Diagram` object from header string

        Wrapper around the :func:`_build_helper` function, with ``string``
        input, skipping building of the relationship lists and without object
        reset (new objects are added to the object).
        """
        self._build_helper(header_string, build_from='string',
                           flag_build_lists=False, flag_reset=False)

    def add_from_string_list(self, string_list):
        """Augment `Diagram` object from list of header strings

        Wrapper around the :func:`_build_helper` function, with ``string_list``
        input, building the relationship lists and without object reset (new
        objects are added to the object).
        """
        self._build_helper(string_list, build_from='string_list',
                           flag_build_lists=False, flag_reset=False)

    def build_relationship_lists(self):
        """Build inheritance and composition lists from parsed objects

        This method successively calls the :func:`build_inheritance_list` and
        :func:`build_composition_list` methods.
        """
        self.build_inheritance_list()
        self.build_composition_list()

    def parse_objects(self, header_file, arg_type='string'):
        """Parse objects

        This method parses file of string inputs using the CppHeaderParser
        module and extracts internal objects for rendering.

        Parameters
        ----------
        header_file : str
            A string containing C++ header code or a filename with C++ header
            code
        arg_type : str
            It set to ``string``, ``header_file`` is considered to be a string,
            otherwise, it is assumed to be a filename
        """
        # Parse header file
        parsed_header = CppHeaderParser.CppHeader(header_file,
                                                  argType=arg_type)
        for container_type, container_iterator, \
            container_handler in CONTAINER_TYPE_MAP:
            objects = parsed_header.__getattribute__(container_type)
            for obj in container_iterator(objects):
                self._objects.append(container_handler(obj))

    def build_inheritance_list(self):
        """Build list of inheritance between objects

        This method lists all the inheritance relationships between objects
        contained in the `Diagram` object (external relationships are ignored).

        The implementation establishes a list of available classes and loops
        over objects to obtain their inheritance.  When parent classes are in
        the list of available classes, their a `ClassInheritanceRelationship`
        object is added to the list.
        """
        # Build list of classes in diagram
        class_list = [obj.get_name() for obj in self._objects
                      if isinstance(obj, Class)]

        # Create relationships

        # Inheritance
        for obj in self._objects:
            obj_name = obj.get_name()
            if isinstance(obj, Class):
                for parent in obj.build_inheritance_list():
                    if parent in class_list:
                        self._inheritance_list.append(
                            ClassInheritanceRelationship(parent, obj_name))

    def build_composition_list(self):
        """Build list of composition relationships

        This method loops over objects and finds members with type
        corresponding to other classes defined in the `Diagram` object (keeping
        a count of occurrences).

        The procedure first build an internal dictionary of relationships
        found, augmenting the count using the :func:`_augment_comp` function.
        In a second phase, `ClassCompositionRelationship` objects are created
        for each relationships, using the calculated count.
        """
        # Build list of classes in diagram
        class_list = [obj.get_name() for obj in self._objects
                      if isinstance(obj, Class)]

        # Build member type list
        variable_type_list = {}
        for obj in self._objects:
            obj_name = obj.get_name()
            if isinstance(obj, Class):
                variable_type_list[obj_name] = obj.build_variable_type_list()
        # Create composition links
        composition_counts = {}

        for child_class in class_list:
            if child_class in variable_type_list.keys():
                var_types = variable_type_list[child_class]
                for var_type in var_types:
                    for parent in class_list:
                        if re.search(r'\b' + parent + r'\b', var_type):
                            self._augment_comp(composition_counts, parent,
                                               child_class)
        for obj_class, obj_comp_list in composition_counts.items():
            for comp_parent, comp_count in obj_comp_list:
                self._composition_list.append(
                    ClassCompositionRelationship(obj_class, comp_parent,
                                                 comp_count))

    def _augment_comp(self, c_dict, c_parent, c_child):
        """Increment the composition reference count

        If the composition relationship is not in the list (``c_dict``), then
        add a new entry with count 1.  If the relationship is already in the
        list, then increment the count.

        Parameters
        ----------
        c_dict : dict
            List of composition relationships.  For each dictionary key, a pair
            of (str, int) elements: string and number of occurrences
        c_parent : str
            Parent class name
        c_child : str
            Child class name
        """
        if c_child not in c_dict:
            c_dict[c_child] = [[c_parent, 1], ]
        else:
            parent_list = [c[0] for c in c_dict[c_child]]
            if c_parent not in parent_list:
                c_dict[c_child].append([c_parent, 1])
            else:
                c_idx = parent_list.index(c_parent)
                c_dict[c_child][c_idx][1] += 1

    def render(self):
        """Render full UML diagram

        The string returned by this function should be ready to use with the
        PlantUML program.  It includes all the parsed objects with their
        members, and the inheritance and composition relationships extracted
        from the list of objects.

        Returns
        -------
        str
            String containing the full string representation of the `Diagram`
            object, including objects and object relationships
        """
        # Preamble
        diagram_str = self._preamble()

        # Objects
        for obj in self._objects:
            diagram_str += obj.render() + '\n'

        # Inheritance
        for inherit in self._inheritance_list:
            diagram_str += inherit.render() + '\n'

        # Composition
        for comp in self._composition_list:
            diagram_str += comp.render() + '\n'

        # Postamble
        diagram_str += self._postamble()

        return diagram_str

    def _preamble(self):
        """PlantUML preamble text

        Returns
        -------
        str
            The PlantUML preamble text: ``@startuml``
        """
        return '@startuml\n'

    def _postamble(self):
        """PlantUML postamble text

        Returns
        -------
        str
            The PlantUML postamble text: ``@enduml``
        """
        return '\n@enduml\n'
#+END_SRC


** REVIEW Helper functions

This section briefly describes the helper functions defined in the module.

*** REVIEW Sanitize type string

The ~_cleanup_type~ function tries to unify the string representation of types
by eliminating spaces =*= characters.

#+NAME: py-helper-cleanup-str
#+BEGIN_SRC python
# %% Cleanup object type string


def _cleanup_type(type_str):
    """Cleanup string representing a C++ type

    Cleanup simply consists in removing spaces before a ``*`` character and
    preventing multiple successive spaces in the string.

    Parameters
    ----------
    type_str : str
        A string representing a C++ type definition

    Returns
    -------
    str
        The type string after cleanup
    """
    return re.sub(r'[ ]+\*', '*',
                  re.sub(r'(\s)+', r'\1', type_str))
#+END_SRC


*** REVIEW Expand file list

The [[#sec-module-create-uml][main interface function]] accepts wildcards in filenames; they are resolved
using the =glob= package.  The ~expand_file_list~ function takes as input a list
of filenames and expands wildcards using the ~glob~ command returning a list of
existing filenames without wildcards.

#+NAME: py-build-file-list
#+BEGIN_SRC python
# %% Expand wildcards in file list


def expand_file_list(input_files):
    """Find all files in list (expanding wildcards)

    This function uses `glob` to find files matching each string in the input
    list.

    Parameters
    ----------
    input_files : list(str)
        List of strings representing file names and possibly including
        wildcards

    Returns
    -------
    list(str)
        List of filenames (with wildcards expanded).  Each element contains the
        name of an existing file
    """
    file_list = []
    for input_file in input_files:
        file_list += glob.glob(input_file)
    return file_list
#+END_SRC


** REVIEW Main function: create PlantUML from C++
  :PROPERTIES:
  :CUSTOM_ID: sec-module-create-uml
  :END:

The ~CreatePlantUMLFile~ function is the main entry point for the module.  It
takes as input a list of header files (possibly with wildcards) and an output
filename and converts the input header files into a text file ready for use with
the PlantUML program.

The function creates a ~Diagram~ object, initializes it with the expanded list
of input files and writes the content of the ~Diagram.render()~ method to the
output file.

#+NAME: py-create-plantuml
#+BEGIN_SRC python
# %% Main function


def CreatePlantUMLFile(file_list, output_file=None):
    """ Create PlantUML file from list of header files

    This function parses a list of C++ header files and generates a file for
    use with PlantUML.

    Parameters
    ----------
    file_list : list(str)
        List of filenames (possibly, with wildcards resolved with the
        :func:`expand_file_list` function)
    output_file : str
        Name of the output file
    """
    if isinstance(file_list, str):
        file_list_c = [file_list, ]
    else:
        file_list_c = file_list
    diag = Diagram()
    diag.create_from_file_list(list(set(expand_file_list(file_list_c))))
    diag_render = diag.render()

    if output_file is None:
        print(diag_render)
    else:
        with open(output_file, 'wt') as fid:
            fid.write(diag_render)
#+END_SRC


** REVIEW Command line interface

The ~main~ function provides a minimal command line interface using =argparse=
to parse input arguments.  The function passes the command line arguments to the
[[#sec-module-create-uml][~CreatePlantUMLFile~]] function.

#+NAME: py-cmd-main
#+BEGIN_SRC python
# %% Command line interface


def main():
    """Command line interface

    This function is a command-line interface to the
    :func:`hpp2plantuml.CreatePlantUMLFile` function.

    Arguments are read from the command-line, run with ``--help`` for help.
    """
    parser = argparse.ArgumentParser(description='hpp2plantuml tool.')
    parser.add_argument('-o', '--output-file', dest='output_file',
                        required=False, default=None, metavar='FILE',
                        help='Output file')
    parser.add_argument('-i', '--input-file', dest='input_files',
                        action='append', metavar='HEADER-FILE', required=True,
                        help='Input file')
    args = parser.parse_args()
    if len(args.input_files) > 0:
        CreatePlantUMLFile(args.input_files, args.output_file)

# %% Standalone mode


if __name__ == '__main__':
    main()
#+END_SRC


* REVIEW Usage

#+NAME: doc-usage
#+BEGIN_SRC org

The ~hpp2plantuml~ package can be used from the command line or as a module in
other applications.


,* Command line

The command line usage is (~hpp2plantuml --help~):


,#+BEGIN_EXAMPLE
usage: command_line.py [-h] -o FILE -i HEADER-FILE

hpp2plantuml tool.

optional arguments:
  -h, --help            show this help message and exit
  -o FILE, --output-file FILE
                        Output file
  -i HEADER-FILE, --input-file HEADER-FILE
                        Input file
,#+END_EXAMPLE


Input files are added using the ~-i~ option.  Inputs can be file paths or
include wildcards.  The output file is selected with the ~-o~ option.  The
output is a text file following the PlantUML syntax.

For instance, the following command will generate the input file for PlantUML
from several header files and store the output to the =output.puml= file.

,#+NAME: usage-sh
,#+BEGIN_SRC sh
hpp2plantuml -i File_1.hpp -i include/Helper_*.hpp -o output.puml
,#+END_SRC


,* Module

To use as a module, simply ~import hpp2plantuml~.  The ~CreatePlantUMLFile~ can
then be used to create a PlantUML file from a set of input files.
Alternatively, the ~Diagram~ object can be used directly to build internal
objects (from files or strings).  The ~Diagram.render()~ method can be used to
produce a string output instead of writing to a text file.
#+END_SRC


* TODO Tests
 :PROPERTIES:
 :header-args:python+: :tangle tests/test_hpp2plantuml.py
 :END:

#+NAME: test-setup
#+BEGIN_SRC python
"""Test module for hpp2plantuml"""

# %% Imports

import os
import nose.tools as nt
import CppHeaderParser
import hpp2plantuml

test_fold = os.path.abspath(os.path.dirname(__file__))

# %% Helper functions


def get_parsed_element(input_str):
    return CppHeaderParser.CppHeader(input_str, argType='string')
#+END_SRC

** TODO Unit tests

#+NAME: test-unit-container
#+BEGIN_SRC python
# %% Test containers


class TestContainer:
    def test_init(self):
        c_type = "container_type"
        c_name = "container_name"
        c_obj = hpp2plantuml.hpp2plantuml.Container(c_type, c_name)
        nt.assert_equal(c_obj.get_name(), c_name)
        nt.assert_equal(c_obj.render(), 'container_type container_name {\n}\n')

    def test_comparison_keys(self):
        c_list = [
            ['class', 'ABD'],
            ['enum', 'ABDa'],
            ['class', 'abcd'],
        ]
        ref_sort_idx = [0, 2, 1]
        c_obj_list = []
        for c_type, c_name in c_list:
            c_obj_list.append(hpp2plantuml.hpp2plantuml.Container(
                c_type, c_name))
        c_obj_list.sort(key=lambda obj: obj.comparison_keys())

        for i in range(len(c_list)):
            nt.assert_equal(c_obj_list[i].get_name(),
                            c_list[ref_sort_idx[i]][1])
#+END_SRC

#+NAME: test-unit-class
#+BEGIN_SRC python
class TestClass:
    def test_init(self):
        input_str = """
class TestClass {
public:
int _p_member;
};
"""
        output_ref_str = """class TestClass {
	+_p_member : int
}
"""
        p = get_parsed_element(input_str)
        class_input = ['TestClass', p.classes['TestClass']]
        obj_c = hpp2plantuml.hpp2plantuml.Class(class_input)
        nt.assert_equal(output_ref_str, obj_c.render())
#+END_SRC


** TODO Full system test

*** TODO Input files

#+NAME: hpp-simple-classes-1-2
#+BEGIN_SRC c++ :mkdirp yes :tangle tests/simple_classes_1_2.hpp
enum Enum01 { VALUE_0, VALUE_1, VALUE_2 };

class Class01 {
protected:
	int _protected_var;
	bool _ProtectedMethod(int param);
	static bool _StaticProtectedMethod(bool param);
	virtual bool _AbstractMethod(int param) = 0;
public:
	int public_var;
	bool PublicMethod(int param);
	static bool StaticPublicMethod(bool param);
	virtual bool AbstractPublicMethod(int param) = 0;
};

class Class02 : public Class01 {
public:
	bool AbstractPublicMethod(int param) override;
private:
	int _private_var;
	bool _PrivateMethod(int param);
	static bool _StaticPrivateMethod(bool param);
	bool _AbstractMethod(int param) override;
};
#+END_SRC

#+NAME: hpp-simple-classes-3
#+BEGIN_SRC c++ :mkdirp yes :tangle tests/simple_classes_3.hpp
template<typename T>
class Class03 {
public:
	Class03();
	~Class03();
private:
	Class01* _obj;
	list<Class02> _obj_list;
	T* _typed_obj;
};
#+END_SRC



*** TODO Reference output


#+NAME: puml-simple-classes
#+BEGIN_SRC plantuml :mkdirp yes :tangle tests/simple_classes.puml
@startuml
abstract class Class01 {
	+{abstract} AbstractPublicMethod(int param) : bool
	+PublicMethod(int param) : bool
	+{static} StaticPublicMethod(bool param) : bool
	#{abstract} _AbstractMethod(int param) : bool
	#_ProtectedMethod(int param) : bool
	#{static} _StaticProtectedMethod(bool param) : bool
	#_protected_var : int
	+public_var : int
}

class Class02 {
	+AbstractPublicMethod(int param) : bool
	-_AbstractMethod(int param) : bool
	-_PrivateMethod(int param) : bool
	-{static} _StaticPrivateMethod(bool param) : bool
	-_private_var : int
}

class Class03 <template<typename T>> {
	+Class03()
	+~Class03()
	-_obj : Class01*
	-_typed_obj : T*
	-_obj_list : list<Class02>
}

enum Enum01 {
	VALUE_0
	VALUE_1
	VALUE_2
}

Class01 <|-- Class02
Class01  *-- Class03
Class02  *-- Class03

@enduml
#+END_SRC


*** TODO Test diagram generation

#+NAME: test-full-diagram
#+BEGIN_SRC python

class TestFullDiagram():

    def __init__(self):
        self._input_files = ['simple_classes_1_2.hpp', 'simple_classes_3.hpp']
        self._input_files_w = ['simple_classes_*.hpp', 'simple_classes_3.hpp']

    def test_full_files(self):
        # Create first version
        file_list_ref = list(set(hpp2plantuml.hpp2plantuml.expand_file_list(
            [os.path.join(test_fold, f) for f in self._input_files])))
        diag_ref = hpp2plantuml.Diagram()
        diag_ref.create_from_file_list(file_list_ref)
        diag_render_ref = diag_ref.render()

        # Compare to saved reference
        with open(os.path.join(test_fold, 'simple_classes.puml'), 'rt') as fid:
            diag_saved_ref = fid.read()
        nt.assert_equal(diag_saved_ref, diag_render_ref)

        # # Validate equivalent inputs

        # File expansion
        for file_list in [self._input_files, self._input_files_w]:
            file_list_c = list(set(hpp2plantuml.hpp2plantuml.expand_file_list(
                [os.path.join(test_fold, f) for f in file_list])))
            diag_c = hpp2plantuml.Diagram()
            diag_c.create_from_file_list(file_list_c)
            nt.assert_equal(diag_render_ref, diag_c.render())

        # String inputs
        input_str_list = []
        for file_c in file_list_ref:
            with open(file_c, 'rt') as fid:
                input_str_list.append(fid.read())
        diag_str_list = hpp2plantuml.Diagram()
        diag_str_list.create_from_string_list(input_str_list)
        nt.assert_equal(diag_render_ref, diag_str_list.render())
        diag_str = hpp2plantuml.Diagram()
        diag_str.create_from_string('\n'.join(input_str_list))
        nt.assert_equal(diag_render_ref, diag_str.render())
        # Reset and parse
        diag_str.clear()
        diag_str.create_from_string('\n'.join(input_str_list))
        nt.assert_equal(diag_render_ref, diag_str.render())

        # Manually build object
        diag_manual_add = hpp2plantuml.Diagram()
        for idx, (file_c, string_c) in enumerate(zip(file_list_ref,
                                                     input_str_list)):
            if idx == 0:
                diag_manual_add.add_from_file(file_c)
            else:
                diag_manual_add.add_from_string(string_c)
        diag_manual_add.build_relationship_lists()
        diag_manual_add.sort_elements()
        nt.assert_equal(diag_render_ref, diag_manual_add.render())
#+END_SRC


* TODO Packaging

** TODO __init__.py

#+NAME: py-init
#+BEGIN_SRC python :noweb yes :tangle src/hpp2plantuml/__init__.py
""" hpp2plantuml module

<<doc-module>>

Usage:

<<doc-module-usage>>
"""

__title__ = "hpp2plantuml"
__description__ = "Convert C++ header files to PlantUML"

__version__ = <<get-version()>>
__uri__ = "https://hpp2plantuml.readthedocs.io/"
__doc__ = __description__ + " <" + __uri__ + ">"

__author__ = "Thibault Marin"
__email__ = "thibault.marin@gmx.com"

__license__ = "MIT"
__copyright__ = "Copyright (c) 2016 Thibault Marin"

from .hpp2plantuml import CreatePlantUMLFile, Diagram

__all__ = ['CreatePlantUMLFile', 'Diagram']

#+END_SRC


** TODO setup.cfg

#+NAME: cfg-setup
#+BEGIN_SRC conf :tangle setup.cfg

[bdist_wheel]
universal = 1

[metadata]
license_file = LICENSE

[build_sphinx]
source-dir = doc/source
build-dir  = doc/build
all_files  = 1

[upload_sphinx]
upload-dir = doc/build/html

#+END_SRC


** TODO setup.py
   :PROPERTIES:
   :CUSTOM_ID: sec-package-setup-py
   :END:

#+NAME: py-setup
#+BEGIN_SRC python :noweb yes :tangle setup.py

# %% Imports
import codecs
import os
import re

from setuptools import setup, find_packages

# %% Custom fields

###################################################################

NAME = "hpp2plantuml"
PACKAGES = find_packages(where="src")
META_PATH = os.path.join("src", NAME, "__init__.py")
KEYWORDS = ["class", "attribute", "boilerplate"]
CLASSIFIERS = [
    "Development Status :: 5 - Production/Stable",
    "Intended Audience :: Developers",
    "Natural Language :: English",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.3",
    "Programming Language :: Python :: 3.4",
    "Programming Language :: Python :: 3.5",
    "Programming Language :: Python :: Implementation :: PyPy",
    "Topic :: Software Development :: Libraries :: Python Modules",
]
INSTALL_REQUIRES = <<py-dependencies("requirements")>>

###################################################################

HERE = os.path.abspath(os.path.dirname(__file__))


def read(*parts):
    """
    Build an absolute path from *parts* and and return the contents of the
    resulting file.  Assume UTF-8 encoding.
    """
    with codecs.open(os.path.join(HERE, *parts), "rb", "utf-8") as f:
        return f.read()


META_FILE = read(META_PATH)


def find_meta(meta):
    """
    Extract __*meta*__ from META_FILE.
    """
    meta_match = re.search(
        r"^__{meta}__ = ['\"]([^'\"]*)['\"]".format(meta=meta),
        META_FILE, re.M
    )
    if meta_match:
        return meta_match.group(1)
    raise RuntimeError("Unable to find __{meta}__ string.".format(meta=meta))


if __name__ == "__main__":
    setup(
        name=NAME,
        description=find_meta("description"),
        license=find_meta("license"),
        url=find_meta("uri"),
        version=find_meta("version"),
        author=find_meta("author"),
        author_email=find_meta("email"),
        maintainer=find_meta("author"),
        maintainer_email=find_meta("email"),
        keywords=KEYWORDS,
        long_description=read("README.rst"),
        packages=PACKAGES,
        package_dir={"": "src"},
        zip_safe=False,
        classifiers=CLASSIFIERS,
        install_requires=INSTALL_REQUIRES,
        test_suite='nose.collector',
        tests_require=['nose'],
        entry_points={
            'console_scripts': ['hpp2plantuml=hpp2plantuml.hpp2plantuml:main']
        }
    )

#+END_SRC


** TODO README


#+NAME: rst-README
#+BEGIN_SRC rst :noweb yes :tangle README.rst

hpp2plantuml - Convert C++ header files to PlantUML
===================================================

<<el-org-to-rst("doc-intro")>>

Usage
-----

<<el-org-to-rst("doc-usage")>>

#+END_SRC


** TODO Documentation

*** Sphinx configuration

#+NAME: py-sphinx-conf
#+BEGIN_SRC python :noweb yes :mkdirp yes :tangle doc/source/conf.py

# -*- coding: utf-8 -*-
#
# hpp2plantuml documentation build configuration file, created by
# sphinx-quickstart on Fri Dec  9 13:26:02 2016.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#
import os
import sys
# sys.path.insert(0, os.path.abspath('.'))
sys.path.insert(0, os.path.abspath("../.."))

# Customizations

autoclass_content = 'both'
autodoc_default_flags = ['members', 'undoc-members', 'private-members']
numpydoc_show_class_members = False

# Customizations

autoclass_content = 'both'
autodoc_default_flags = ['members', 'undoc-members', 'private-members']

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.intersphinx',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.mathjax',
    'sphinx.ext.ifconfig',
    'sphinx.ext.viewcode',
    'sphinx.ext.autosummary',
    'numpydoc'
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix(es) of source filenames.
# You can specify multiple suffix as a list of string:
#
# source_suffix = ['.rst', '.md']
source_suffix = '.rst'

# The encoding of source files.
#
# source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'hpp2plantuml'
copyright = u'2016, Thibault Marin'
author = u'Thibault Marin'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = u'v' + u<<get-version()>>
# The full version, including alpha/beta/rc tags.
release = u'v' + u<<get-version()>>

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set "language" from the command line for these cases.
language = 'en'

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#
# today = ''
#
# Else, today_fmt is used as the format for a strftime call.
#
# today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This patterns also effect to html_static_path and html_extra_path
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all
# documents.
#
default_role = 'autolink'

# If true, '()' will be appended to :func: etc. cross-reference text.
#
# add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#
# add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#
# show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
# modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
# keep_warnings = False

# If true, `todo` and `todoList` produce output, else they produce nothing.
todo_include_todos = True


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
html_theme = 'alabaster'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#
# html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
# html_theme_path = []

# The name for this set of Sphinx documents.
# "<project> v<release> documentation" by default.
#
# html_title = u'hpp2plantuml ' + u'v' + u<<get-version()>>

# A shorter title for the navigation bar.  Default is the same as html_title.
#
# html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#
# html_logo = None

# The name of an image file (relative to this directory) to use as a favicon of
# the docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#
# html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#
# html_extra_path = []

# If not None, a 'Last updated on:' timestamp is inserted at every page
# bottom, using the given strftime format.
# The empty string is equivalent to '%b %d, %Y'.
#
# html_last_updated_fmt = None

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#
# html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#
# html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#
# html_additional_pages = {}

# If false, no module index is generated.
#
# html_domain_indices = True

# If false, no index is generated.
#
# html_use_index = True

# If true, the index is split into individual pages for each letter.
#
# html_split_index = False

# If true, links to the reST sources are added to the pages.
#
# html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#
# html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#
# html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#
# html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
# html_file_suffix = None

# Language to be used for generating the HTML full-text search index.
# Sphinx supports the following languages:
#   'da', 'de', 'en', 'es', 'fi', 'fr', 'hu', 'it', 'ja'
#   'nl', 'no', 'pt', 'ro', 'ru', 'sv', 'tr', 'zh'
#
# html_search_language = 'en'

# A dictionary with options for the search language support, empty by default.
# 'ja' uses this config value.
# 'zh' user can custom change `jieba` dictionary path.
#
# html_search_options = {'type': 'default'}

# The name of a javascript file (relative to the configuration directory) that
# implements a search results scorer. If empty, the default will be used.
#
# html_search_scorer = 'scorer.js'

# Output file base name for HTML help builder.
htmlhelp_basename = 'hpp2plantumldoc'

# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
     # The paper size ('letterpaper' or 'a4paper').
     #
     # 'papersize': 'letterpaper',

     # The font size ('10pt', '11pt' or '12pt').
     #
     # 'pointsize': '10pt',

     # Additional stuff for the LaTeX preamble.
     #
     # 'preamble': '',

     # Latex figure (float) alignment
     #
     # 'figure_align': 'htbp',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
    (master_doc, 'hpp2plantuml.tex', u'hpp2plantuml Documentation',
     u'Thibault Marin', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#
# latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#
# latex_use_parts = False

# If true, show page references after internal links.
#
# latex_show_pagerefs = False

# If true, show URL addresses after external links.
#
# latex_show_urls = False

# Documents to append as an appendix to all manuals.
#
# latex_appendices = []

# It false, will not define \strong, \code, 	itleref, \crossref ... but only
# \sphinxstrong, ..., \sphinxtitleref, ... To help avoid clash with user added
# packages.
#
# latex_keep_old_macro_names = True

# If false, no module index is generated.
#
# latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    (master_doc, 'hpp2plantuml', u'hpp2plantuml Documentation',
     [author], 1)
]

# If true, show URL addresses after external links.
#
# man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    (master_doc, 'hpp2plantuml', u'hpp2plantuml Documentation',
     author, 'hpp2plantuml', 'One line description of project.',
     'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#
# texinfo_appendices = []

# If false, no module index is generated.
#
# texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#
# texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#
# texinfo_no_detailmenu = False


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'https://docs.python.org/': None}

#+END_SRC


*** Index page

#+NAME: doc-rst-index
#+BEGIN_SRC rst :noweb yes :mkdirp yes :tangle doc/source/index.rst

.. hpp2plantuml documentation master file.

hpp2plantuml documentation
==========================

.. toctree::
   :maxdepth: 4

<<el-org-to-rst("doc-intro")>>

Usage
-----

<<el-org-to-rst("doc-usage")>>

Module documentation generated from docstrings
----------------------------------------------

:doc:`hpp2plantuml`

Full org-mode package documentation
-----------------------------------

:doc:`org-doc`

Indices and tables
==================

,* :ref:`genindex`
,* :ref:`modindex`
,* :ref:`search`

#+END_SRC


* TODO Org-mode setup

** REVIEW org-to-rst

The following source block converts the content of an org source block to rst
format using the ~org-rst-convert-region-to-rst~ function.

#+NAME: el-org-to-rst
#+BEGIN_SRC emacs-lisp :var input="doc-intro" :results silent
(save-excursion
  (let* ((temp-output-buffer "*tmp-org-to-rst*")
         (src-info (progn
                     (org-babel-goto-named-src-block input)
                     (org-babel-get-src-block-info t)))
         (src-content (car (cdr src-info))))
    (with-temp-buffer
      (insert src-content)
      (mark-whole-buffer)
      (org-rst-convert-region-to-rst)
      (replace-regexp-in-string "\n$" "" (buffer-string)))))
#+END_SRC


** TODO Tangling

#+NAME: el-tangle-readme
#+BEGIN_SRC emacs-lisp :var input="doc-intro" :results silent
(org-export-to-file 'rst "doc/source/org-doc.rst")
;;(save-excursion
;;  (org-babel-goto-named-src-block "rst-README")
;;  (org-babel-tangle '(4)))
#+END_SRC


** TODO Generate documentation

- One run to export to rst (ox-rst)
- One run to export README.rst


** TODO Blog post setup


* Notes                                                            :noexport:

- [X] Code
  - [X] Add docstrings
  - [X] Add structs
- [-] Add tests
  - [ ] Unit tests
  - [X] Full diagram test
  - [ ] Add test coverage report to documentation
  - [ ] Test structs
- [-] setup.py
  - [X] install doesn't do anything
  - [X] add script to install
  - [ ] add build doc command
- [-] conf.py (sphinx)
  - [X] Include both automatically generated documentation (from docstrings) and
    org file
  - [ ] Render org blocks as regular text
- [ ] Extra files for package
  - [ ] MANIFEST.in?
- [X] Write elisp function which:
  - [X] tangles source files
  - [X] creates documentation rst (and README.rst)
- [X] Link to org-mode rst documentation from index.rst -> Use only org-mode rst?
